RabbitMQ入门

------
# RabbitMQ入门
## 相关概念
RabbitMQ整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。

### 生产者和消费者
#### 生产者（Producer）
投递消息的一方。
创建消息然后发送到RabbitMQ中。消息一般包含2个部分：消息体和标签。
消息体一般是带有业务逻辑结构的数据，如JSON字符串。
标签是用来表述这条消息，比如一个交换器的名称和一个路由键。生产者把消息交由RabbitMQ，RabbitMQ之后会根据标签把消息发送给感兴趣的消费者。

#### 消费者（Consumer）
消息接收的一方。
消费者连接到RabbitMQ服务器上，并订阅到队列上。消费者消费的只是消息的消息体，消息在路由的过程中会把消息的标签丢弃，存入到队列中的消息只有消息体，消费者无需知道生产者是谁。

#### 消息中间件的服务节点（Broker）
对于RabbitMQ来说，一个RabbitMQ Broker可以简单的看做一个RabbitMQ服务节点或者RabbitMQ服务实例。也可以看作是一台RabbitMQ服务器。

生产者将业务数据进行包装，封装成消息，发送到Broker中。消费者订阅并接受消息，经过解包处理得到原始数据，之后进行业务处理。

#### 队列（Queue）
是RabbitMQ的内部对象，用于存储消息。
RabbitMQ中的消息只能存储在队列中。
多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都接收到所有的消息并处理。RabbitMQ不支持队列层面的广播消费。

#### 交换器、路由键、绑定
- 交换器（Exchange）
实际上RabbitMQ中并不是消息生产者直接将消息发到队列中，而是先发到交换器上，由交换器将消息路由到一个或多个队列中，如果路由不到或许会返回给生产者，或许会直接丢弃。

- 路由键（RoutingKey）
生产者将消息发给交换器时，一般会指定一个路由键，用来指定这个消息的路由规则，通过路由键来决定消息流向哪里，而这个路由键需要与交换类型和绑定建联合使用才能最终生效。

- 绑定键（BingingKey）
RabbitMQ中通过绑定将交换器和队列关联起来，在绑定的时候一般会指定一个绑定键，这样RabbitMQ就知道如何正确的将消息路由到队列了。

##### 举个例子
以寄包裹为例  
寄件人相当于消息生产者  
RabbitMQ就相当于邮局、邮箱、邮递员组成的一个系统  
邮箱就相当于交换器  
RoutingKey相当于包裹上写的地址  
BindingKey相当于包裹的目的地  
  
当包裹上的地址和实际想要投递的地址匹配时，就会被正确投递到目的地，目的地（队列）可以保留这个包裹，如果地址写错了，邮递员不能正确投递，包裹可能会被退回给寄件人，也可能被丢弃。  

另外，BindingKey其实也是路由键的一种，为了避免混淆，可以这么理解：  

- 在使用绑定的时候，其中需要的路由键是BindingKey。
- 在发送消息的时候，其中需要的路由键是RoutingKey.
 

#### 交换器类型
RabbitMQ常用的交换器类型有fanout、direct、topic、headers四种。

- fanout  
会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。

- direct  
会把消息路由到那些BindingKey和RoutingKey完全匹配的队列中。

- topic  
是direct的加强版，也是把消息路由到那些BindingKey和RoutingKey相匹配的队列中，但是匹配规则有些不同，约定：

  - RoutingKey是一个点号“.”分隔的字符串，被分隔的每一段独立的字符串称为一个单词，如com.epoint.faep
  - BindingKey和RoutingKey一样也是点号“.”分隔的字符串
  - BindingKey中可以存在两种特殊的字符串“*”和“#”，用于模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词（可以是0个）。

- headers   
headers类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers 属性进行匹配。在绑定队列和交换器时制定一组键值对 当发送消息到交换器时，RabbitMQ会获取到该消息的 headers (也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列 headers类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。

## RabbitMQ运转流程
### 生产者发送消息的流程
- （1）生产者连接到RabbitMQ Broker建立一个连接，开启一个信道（Channel）
- （2）生产者声明一个交换器，并设置相关属性，比如交换器类型，是否持久化等。
- （3）生产者声明一个队列并设置相关属性，如是否排他、是否持久化、是否自动删除等
- （4）生产者通过路由键将交换器和队列绑定起来
- （5）生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息。
- （6）相应的交换器根据收到的路由键查找相匹配的队列。
- （7）如果找到，则将生产者发送过来的消息存入相应的队列中。
- （8）如果没有找到，则根据生产者配置的属性决定丢弃还是退回给生产者。
- （9）关闭信道
- （10）关闭连接

### 消费者接收消息的流程
- （1）消费者连接到RabbitMQ Broker，建立一个连接，开启一个信道。
- （2）消费者向RabbitMQ Broker请求消费队列中的消息，可能会设置相应的回调函数，以及做一些准备工作。
- （3）等待RabbitMQ Broker回应并投递相应队列中的消息，消费者接收消息。
- （4）消费者确认（ack）接收到的消息。
- （5）RabbitMQ从队列中删除相应已经被确认的消息。
- （6）关闭信道。
- （7）关闭连接。

### 引入两个概念：Connection和Channel
无论是生产者还是消费者，都需要和RabbitMQ Broker建立连接，这个连接就是一条TCP连接，也就是Connection。  
一旦TCP连接建立起来，客户端紧接着可以创建一个AMQP信道，每个信道都会被指派一个唯一ID。  
信道是建立在Connection之上的虚拟连接，RabbitMQ处理的每条AMQP指令都是通过信道完成的。  

多个生产者通过复用TCP连接创建多个信道同RabbitMQ Broker建立连接。  

## AMQP协议介绍
RabbitMQ是遵从AMQP协议的，换句话说，RabbitMQ就是AMQP协议的Erlang的实现。
RabbitMQ中的交换器、交换器类型、队列、绑定、路由键等都是遵循的AMQP协议中的相应概念。

### AMQP协议本身包括三层：
- Module Layer:位于协议最高层，主要定义了一些供客户端调用的命令，客户端可以利用这些命令实现自己的业务逻辑。
- Session Layer:位于中间层，主要负责将客户端的命令发送给服务器，再将服务端的应答返回给客户端，主要为客户端与服务器之间的通信提供可靠性同步机制和错误处理。
- Transport Layer:位于最底层，主要传输二进制数据流，提供帧的处理、信道复用、错误检测和数据表示等。
