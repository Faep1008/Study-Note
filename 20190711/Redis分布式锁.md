# 基于Redis做分布式锁


## 一、锁
- 单进程系统中，存在多个线程可以同时改变某个可变共享变量时，需要对变量或代码块做同步，使其能够在修改这种变量的时候能够消除并发修改变量。
- 同步的本质就是通过锁来实现的，为了实现多个线程在一个时刻同一个代码块只能有一个线程可执行，那么需要在某个地方做标记，这个标记必须每个线程都能看到，当标记不存在时可以设置该标记，其余后续线程发现已经有标记了则等待拥有该标记的线程结束同步代码块取消标记后再尝试设置标记，这个标记可以理解为锁。
- 不同地方实现锁的方式也不一样，只要能满足所有线程都能看得到标记即可。如 Java 中 synchronize 是在对象头设置标记，Lock 接口的实现类基本上都只是某一个 volitile 修饰的 int 型变量其保证每个线程都能拥有对该 int 的可见性和原子修改，linux 内核中也是利用互斥量或信号量等内存数据做标记。


## 二、分布式
首先了解一下分布式的 CAP 理论  
CAP三个字母分别代表：  
- C - Consistent ，一致性
- A - Availability ，可用性
- P - Partition tolerance ，分区容错性  

分布式系统之所以叫分布式，是因为提供服务的各个节点分布在不同机器上，相互之间通过网络交互。  
那么必然存在网络故障断开的风险，这个网络断开的专业场景称为网络分区。   
在网络分区发生时，两个分布式节点之间无法进行通信，那么我们对一个节点进行的修改操作将无法同步到另外一个节点，所以数据的「一致性」将无法满足，因为两个分布式节点的数据不再保持一致。  
除非我们牺牲「可用性」，也就是暂停分布式节点服务，在网络分区发生时，不再提供修改数据的功能，直到网络状况完全恢复正常再继续对外提供服务。或者为了保证可用性，而牺牲数据一致性。  
所以，CAP一句话就是，在网络分区时，不能同时保证可用性和一致性。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证最终一致性。  
在许多的场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。  
### 在单机环境中，通过 Java 提供的并发 API 我们可以解决，但是在分布式环境下就有区别了：
- 分布式与单机情况下最大的不同在于其不是多线程而是多进程。
- 多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。


## 三、分布式锁
- 当在分布式场景下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。
- 与单机模式下的锁不同的是，不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。
- 分布式锁还是可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存如 Redis、Memcache。至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。

## 四、基于 Redis 做分布式锁
### 方式一、基于 Redis的 setnx()、expire() 方法做分布式锁
#### setnx()
setnx 的含义就是 SET if Not Exists，其主要有两个参数 setnx(key, value)。该方法是原子的，如果 key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0。
#### expire()
expire 设置过期时间，要注意的是 setnx 命令不能设置 key 的超时时间，只能通过 expire() 来对 key 设置。
#### 使用步骤
- 1、setnx(lockkey, 1) 如果返回 0，则说明占位失败；如果返回 1，则说明占位成功
- 2、expire() 命令对 lockkey 设置超时时间，为的是避免死锁问题。
- 3、执行完业务代码后，可以通过 delete 命令删除 key。  
这个方案其实是可以解决日常工作中的需求的，但从技术方案的探讨上来说，可能还有一些可以完善的地方。比如，如果在第一步 setnx 执行成功后，在 expire() 命令执行成功前，发生了宕机的现象，那么就依然会出现死锁的问题。
下面是优化后的方案

### 方式二、基于 Redis的 setnx()、get()、getset()方法做分布式锁
#### getset()命令说明
这个命令主要有两个参数 getset(key，newValue)。  
该方法是原子的，对 key 设置 newValue 这个值，并且返回 key 原来的旧值。  
假设 key 原来是不存在的，那么多次执行这个命令，会出现下边的效果：  
- getset(key, “value1”) 返回 null 此时 key 的值会被设置为 value1
- getset(key, “value2”) 返回 value1 此时 key 的值会被设置为 value2
- 以此类推

#### 使用步骤
- 1、setnx(lockkey, 当前时间+过期超时时间)，如果返回 1，则获取锁成功；如果返回 0 则没有获取到锁，转向 2。
- 2、get(lockkey) 获取值 oldExpireTime ，并将这个 value 值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向 3。
- 3、计算 newExpireTime = 当前时间+过期超时时间，然后 getset(lockkey, newExpireTime) 会返回当前 lockkey 的值currentExpireTime。
- 4、判断 currentExpireTime 与 oldExpireTime 是否相等，如果相等，说明当前 getset 设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。
- 5、在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行 delete 释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。  

  
参考资料  
http://www.hollischuang.com/archives/1716  
http://www.spring4all.com/question/158  
https://www.cnblogs.com/PurpleDream/p/5559352.html  
http://www.cnblogs.com/PurpleDream/p/5573040.html  
https://www.cnblogs.com/suolu/p/6588902.html  
http://www.54tianzhisheng.cn/2018/04/24/Distributed_lock/  
